# Map в Java

В Java интерфейс Map представляет собой коллекцию, которая хранит данные в виде пар ключ-значение. Каждый элемент в Map состоит из уникального ключа и связанного с ним значения. Основные особенности интерфейса Map:

* Уникальные ключи: Каждый ключ в Map должен быть уникальным. Это означает, что в Map не может быть двух элементов с одинаковыми ключами.
* Пары ключ-значение: Каждый элемент в Map представляет собой пару ключ-значение, где ключ используется для доступа к значению.
* Методы доступа: Интерфейс Map предоставляет методы для добавления, удаления, получения и обновления элементов по ключу.
* Итерация: Map поддерживает итерацию по элементам, что позволяет обходить все пары ключ-значение в коллекции.
* Различные реализации: В Java существует несколько реализаций интерфейса Map, таких как HashMap, TreeMap, LinkedHashMap и другие, каждая из которых имеет свои особенности и применения.

## HashMap
Хранит ключи и значения в хэш-таблице.
Не гарантирует порядок элементов.
Обеспечивает быстрый доступ к элементам за константное время (O(1)) в среднем.

Основные методы для работы с HashMap в Java:
* put(K key, V value): Добавляет элемент с указанным ключом и значением в HashMap. Если элемент с таким ключом уже существует, значение будет заменено.
* get(Object key): Возвращает значение, связанное с указанным ключом, или null, если ключ не найден в HashMap.
* remove(Object key): Удаляет элемент с указанным ключом из HashMap и возвращает значение, связанное с этим ключом, или null, если ключ не найден.
* containsKey(Object key): Проверяет, содержит ли HashMap элемент с указанным ключом. Возвращает true, если ключ найден, иначе false.
* containsValue(Object value): Проверяет, содержит ли HashMap элемент с указанным значением. Возвращает true, если значение найдено, иначе false.
* size(): Возвращает количество элементов (пар ключ-значение) в HashMap.
* isEmpty(): Проверяет, пуста ли HashMap. Возвращает true, если HashMap не содержит элементов, иначе false.
* clear(): Удаляет все элементы из HashMap, делая его пустым.
* keySet(): Возвращает множество всех ключей (Set<K>) в HashMap.
* values(): Возвращает коллекцию всех значений (Collection<V>) в HashMap.
* entrySet(): Возвращает множество элементов (Set<Map.Entry<K, V>>) в виде объектов Map.Entry, представляющих пары ключ-значение.

## TreeMap

Хранит ключи и значения в отсортированном порядке по ключу.
Позволяет получить элементы в порядке возрастания ключей.
Поддерживает дополнительные операции, такие как получение подмножества элементов.

Помимо методов, которые уже были перечислены для HashMap, TreeMap также предоставляет дополнительные методы, специфичные для его особенностей в качестве отсортированной коллекции. Вот некоторые из дополнительных методов, которые предоставляет TreeMap:
* firstKey(): Возвращает наименьший ключ в TreeMap.
* lastKey(): Возвращает наибольший ключ в TreeMap.
* headMap(K toKey): Возвращает представление всех элементов, ключи которых меньше, чем указанный toKey.
* tailMap(K fromKey): Возвращает представление всех элементов, ключи которых больше или равны указанному fromKey.
* subMap(K fromKey, K toKey): Возвращает представление всех элементов, ключи которых находятся в диапазоне от fromKey (включительно) до toKey (исключительно).
* comparator(): Возвращает компаратор, используемый для сортировки ключей в TreeMap, или null, если TreeMap использует естественный порядок ключей.
* descendingKeySet(): Возвращает нисходящий набор ключей, который обеспечивает обратный порядок итерации по ключам.
* descendingMap(): Возвращает нисходящее представление TreeMap, которое обеспечивает обратный порядок итерации по элементам.

Эти методы позволяют работать с TreeMap как с отсортированной коллекцией, обеспечивая доступ к элементам в упорядоченном виде и предоставляя возможность выполнения операций на подмножествах элементов в соответствии с их ключами.

## LinkedHashMap:

Сохраняет порядок вставки элементов, что позволяет итерироваться по элементам в том порядке, в котором они были добавлены.
Поддерживает доступ к элементам по ключу и порядковому номеру вставки.
ConcurrentHashMap:

Потокобезопасная реализация Map, которая позволяет множеству потоков одновременно читать и изменять элементы.
Использует разные сегменты для разных потоков, что уменьшает конфликты при доступе к элементам.

Вот некоторые из дополнительных методов, которые предоставляет LinkedHashMap:

* removeEldestEntry(Map.Entry<K,V> eldest): Метод, который вызывается после каждой операции добавления элемента в LinkedHashMap. Позволяет определить, нужно ли удалить старый элемент (самый старый, основанный на порядке вставки) при добавлении нового элемента. Этот метод может быть переопределен для создания кэширующих LinkedHashMap.
* getOrDefault(Object key, V defaultValue): Возвращает значение, связанное с указанным ключом, или defaultValue, если ключ не найден в LinkedHashMap.
* forEach(BiConsumer<? super K,? super V> action): Выполняет указанное действие для каждой пары ключ-значение в LinkedHashMap.
* replace(K key, V value): Заменяет значение, связанное с указанным ключом, на указанное значение.
* replace(K key, V oldValue, V newValue): Заменяет значение, связанное с указанным ключом, на новое значение только в том случае, если текущее значение совпадает с oldValue.
* computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction):Вычисляет значение для указанного ключа, если ключ отсутствует в LinkedHashMap, используя заданную функцию.
* computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction): Вычисляет новое значение для указанного ключа только в том случае, если ключ присутствует в LinkedHashMap, используя заданную функцию.
* compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction): Вычисляет новое значение для указанного ключа, используя заданную функцию, независимо от того, присутствует ли ключ в LinkedHashMap или нет.

Эти методы позволяют работать с LinkedHashMap как с коллекцией, сохраняющей порядок вставки элементов, и предоставляют дополнительные возможности для манипуляции данными в LinkedHashMap.

## WeakHashMap:

Использует слабые ссылки для ключей, что позволяет сборщику мусора удалять элементы, если на них нет сильных ссылок.
Полезен для кеширования или хранения временных данных, которые могут быть удалены при нехватке памяти.

Помимо методов, общих для всех реализаций Map, WeakHashMap предоставляет дополнительные методы:

* size(): Возвращает количество пар ключ-значение в WeakHashMap.
* isEmpty(): Проверяет, пуст ли WeakHashMap. Возвращает true, если WeakHashMap не содержит элементов, иначе false.
* containsKey(Object key): Проверяет, содержит ли WeakHashMap ключ. Возвращает true, если ключ найден, иначе false.
* containsValue(Object value): Проверяет, содержит ли WeakHashMap значение. Возвращает true, если значение найдено, иначе false.
* get(Object key): Возвращает значение, связанное с указанным ключом, или null, если ключ не найден в WeakHashMap.
* put(K key, V value): Добавляет элемент с указанным ключом и значением в WeakHashMap.
* remove(Object key): Удаляет элемент с указанным ключом из WeakHashMap и возвращает значение, связанное с этим ключом, или null, если ключ не найден.
* clear(): Удаляет все элементы из WeakHashMap, делая его пустым.
* keySet(): Возвращает множество всех ключей (Set<K>) в WeakHashMap.
* values(): Возвращает коллекцию всех значений (Collection<V>) в WeakHashMap.
* entrySet(): Возвращает множество элементов (Set<Map.Entry<K, V>>) в виде объектов Map.Entry, представляющих пары ключ-значение.

WeakHashMap полезен в ситуациях, когда требуется временное хранение данных и необходимо избежать утечек памяти за счет автоматического удаления ключей, на которые больше нет сильных ссылок.

## EnumMap:

Реализация Map, где ключами могут быть только элементы перечисления (enum).
Предоставляет высокую производительность и безопасность типов за счет использования enum в качестве ключей.

Помимо методов, общих для всех реализаций Map, EnumMap предоставляет дополнительные методы:
* EnumMap(Class<K> keyType): Конструктор, который создает пустую EnumMap для указанного типа перечисления keyType.
* EnumMap(EnumMap<K,? extends V> m): Конструктор, который создает EnumMap, содержащую те же отображения, что и указанная EnumMap m.
* EnumMap(Map<K,? extends V> m): Конструктор, который создает EnumMap, содержащую те же отображения, что и указанная Map m.
* clone(): Создает и возвращает копию EnumMap.
* keySet(): Возвращает множество всех ключей (EnumSet<K>) в EnumMap.
* entrySet(): Возвращает множество элементов (Set<Map.Entry<K, V>>) в виде объектов Map.Entry, представляющих пары ключ-значение.
* containsValue(Object value): Проверяет, содержит ли EnumMap указанное значение. Возвращает true, если значение найдено, иначе false.
* containsKey(Object key): Проверяет, содержит ли EnumMap указанный ключ. Возвращает true, если ключ найден, иначе false.
* getOrDefault(Object key, V defaultValue): Возвращает значение, связанное с указанным ключом, или defaultValue, если ключ не найден в EnumMap.

EnumMap обеспечивает быстрый доступ к данным, используя перечисления в качестве ключей, и предоставляет удобные методы для работы с данными, специфичными для перечислений.

## IdentityHashMap:

Сравнивает ключи по ссылке, а не по значению, что делает его полезным в определенных сценариях, где требуется точное сравнение ссылок.

IdentityHashMap предоставляет дополнительные методы:
* size(): Возвращает количество пар ключ-значение в IdentityHashMap.
* isEmpty(): Проверяет, пуст ли IdentityHashMap. Возвращает true, если IdentityHashMap не содержит элементов, иначе false.
* containsKey(Object key): Проверяет, содержит ли IdentityHashMap ключ. Возвращает true, если ключ найден, иначе false.
* containsValue(Object value): Проверяет, содержит ли IdentityHashMap значение. Возвращает true, если значение найдено, иначе false.
* get(Object key): Возвращает значение, связанное с указанным ключом, или null, если ключ не найден в IdentityHashMap.
* put(K key, V value): Добавляет элемент с указанным ключом и значением в IdentityHashMap.
* remove(Object key): Удаляет элемент с указанным ключом из IdentityHashMap и возвращает значение, связанное с этим ключом, или null, если ключ не найден.
* clear(): Удаляет все элементы из IdentityHashMap, делая его пустым.
* keySet(): Возвращает множество всех ключей (Set<K>) в IdentityHashMap.
* values(): Возвращает коллекцию всех значений (Collection<V>) в IdentityHashMap.
* entrySet(): Возвращает множество элементов (Set<Map.Entry<K, V>>) в виде объектов Map.Entry, представляющих пары ключ-значение.

IdentityHashMap полезен в ситуациях, когда требуется сравнивать ключи по ссылке, а не по их содержимому, и когда необходимо учитывать идентичность объектов при работе с отображением.

## Пример
Для наглядного понимания разницы между подходами, когда сравнение происходит по содержимому (equals) и по ссылке (==), рассмотрим следующий пример:

Предположим, у нас есть два разных объекта с одинаковым содержимым, но разными ссылками:

```Java
Object obj1 = new Object();
Object obj2 = new Object();
```

Если мы используем IdentityHashMap для хранения значений и пытаемся получить значение, используя obj1 и obj2 в качестве ключей, то результат будет разный, потому что IdentityHashMap сравнивает ключи по ссылке:

```Java
IdentityHashMap<Object, String> identityMap = new IdentityHashMap<>();
identityMap.put(obj1, "значение для obj1");

// Попытка получить значение, используя obj1 и obj2
System.out.println(identityMap.get(obj1)); // Вывод: значение для obj1
System.out.println(identityMap.get(obj2)); // Вывод: null
```

Теперь рассмотрим пример с использованием HashMap, который сравнивает ключи по содержимому (equals):

```Java
HashMap<Object, String> hashMap = new HashMap<>();
hashMap.put(obj1, "значение для obj1");

// Попытка получить значение, используя obj1 и obj2
System.out.println(hashMap.get(obj1)); // Вывод: значение для obj1
System.out.println(hashMap.get(obj2)); // Вывод: значение для obj1
```

В результате использования IdentityHashMap значение для obj2 будет null, так как ключ obj2 не найден из-за различия в ссылках, в то время как в HashMap значение будет найдено, так как ключ obj2 равен ключу obj1 по содержимому.

Таким образом, разница между IdentityHashMap и HashMap заключается в том, что IdentityHashMap сравнивает ключи по ссылке, в то время как HashMap сравнивает ключи по содержимому.